---
title: Swift
noindex: true
toc: true
---

# Swift

Getting back into it after a few years away. I began by reading the 2022-09-12 version of The Swift Programming Language. TODO go through my highlights of that on Kindle

## Type system

### [WWDC 2022 110353 – Design protocol interfaces in Swift](https://developer.apple.com/videos/play/wwdc2022/110353/)

I came into this wanting to know more about the `any MyProtocol` meaning, and also the meaning of "primary associated type", neither of which are explained in TSPL but which I'd heard elsewhere (possibly in this talk at some other time).

Builds on "Embrace Swift generics" talk, will watch that after

#### Understand type erasure

> "Let's start by learning how protocols with associated types interact with existential types."

`Animal` has an associated `CommodityType` that they `.produce()`, then we have a `Farm` with an array `var animals: [any Animal]`.

> "… the `any Animal` type has a box(ed?) representation that has the ability to store any type of animal dynamically"

> "…the strategy of using the same representation for different concrete types is called _type erasure_"

Now explains why `animals.map { $0.produce() }` returns `[any Food]`:

> "The return type of `produce()` is an associated type. When you call a method returning an associated type on an existential type, the compiler will use type erasure to determine the result type of the call. Type erasure replaces these associated types with corresponding existential types that have equivalent constraints."

The type `any Food` is called the _upper bound_ of the associated `CommodityType`.

Associated types appearing in the result of a function declaration are said to be in a _producing position_. Associated types in producing position are type erased to their upper bound.

On the other hand, associated int he parameter list of a function declaration are said to be in the _consuming position_ (e.g. `eat(_: FeedType)`)

> "type erasure does not allow us to work with associated types in consuming position. Instead you must unbox the existential `any` type by passing it to a function that takes an opaque `some` type.

#### Hide implementation details

We add `var isHungry: Bool` to `Animal`. We have `Farm.feedAnimals()` which feeds all the hungry animals. And a `hungryAnimals` property that initially returns `[any Animal]`, but which we decide to optimise by returning `animals.lazy.filter(\.isHungry)` and hence returns `LazyFilterSequence<[any Animal>]`. But the client doesn't care about this implementation detail.

So we can use an opaque result type to hide the concrete type. But if we just wrote `var hungryAnimals: some Collection` we'd be hiding _too much_ type information - we wouldn't know the collection’s `Element` type.

So we can use a _constrained result type_ (new in Swift 5.7). Written by applying type arguments in angle brackets after the protocol name, e.g. `some Collection<any Animal>`.

This works because the `Collection` protocol declares that the `Element` associated type is a _primary associated type_, which is declared in angle brackets after the protocol name:

```swift
protocol Collection<Element>: Sequence {
	associatedtype Element
	...
}
```

> "Often you'll see a correspondence between the primary associated types of a protocol and the generic parameters of a concrete type conforming to this protocol" – e.g. `Array<Element>`, `Set<Element>`

And in Swift 5.7 we have _constrained existential types_ (i.e. can now do `any Collection<Element>`.)

#### Identify type relationships

Imagine we have:

```swift
struct Cow: Animal {
	func eat(_: Hay) { ... }
}

struct Hay: AnimalFeed {
	static func grow() -> Alfalfa { ... }
}

struct Alfalfa: Crop {
	func harvest () -> Hay { ...
}

let cow: Cow = ...
let alfalfa = Hay.grow()
let hay = alfalfa.harvest()

cow.eat(hay)
```

and also similarly with `Scratch`, which we `grow()` to create `Millet`, which a `Chicken` can then `eat(:_)`.

So, how will `Farm`’s `feedAnimals()` work? It’s going to loop through its `hungryAnimals`, and call `feedAnimal(animal)`.

At that point, we need to "unbox the existential type", which seems to mean something (?) happening to turn `any Animal` into `some Animal`.

```swift
private func feedAnimal(_ animal: some Animal)`
```

But what does that implementation look like?

(By the way, I didn't see TSPL talking about using `some` in a producing position, but we're seeing it here…)

So we do this:

```swift
let crop = type(of: animal).FeedType.grow()
let feed = crop.harvest()
animal.eat(feed)
```

(Is that `type(of: animal)` known at compile time?)

But apparently this doesn't guarantee that we get back the same type of animal feed we started with.

Oh, looks like this is just getting at making sure we use a same-type requirement with a `where` clause:

```swift
associatedtype CropType: Crop where CropType.FeedType === Self
```

(I think this is nothing new, might have missed something here.)

### [WWDC 2022 110352 - Embrace Swift generics](https://developer.apple.com/videos/play/wwdc2022/110352/)

This seems to be building up the thing from before of growing crops, which we then harvest, which we then feed to multiple animals. Starts with concrete example with a cow etc, and then shows how generics allow us to model this.

Says that this is a really common pattern:

```swift
func feed<A>(_ animal: A) where A: Animal
```

which can now be expressed (with identical meaning) in terms of the protocol conformance as

```swift
func feed(_ animal: some Animal)
```

(I think this is new in Swift 5.7.)

The specific underlying type that is substituted in to an opaque type is called the _underlying type_.

Local variables with opaque type must always have an initial value.

Think of `any Animal` as a box, formally called an _existential type_.

How do we call `animal.eat(_:)` on an `any Animal`? We need to unbox it – i.e. convert an instance of `any Animal ` to `some Animal` by _unboxing_ the existential type. "Opening type-erased boxes". New in Swift 5.7. (See the full implementation, using `type(of: animal` in the talk I described above.)

In general, write `some` by default.

## Concurency

### [WWDC 2021 10132 - Meet async/await in Swift](https://developer.apple.com/videos/play/wwdc2021/10132/)

#### Basics

I _think_ this is a concept that is more simple than structured concurrency (that is, `Task`s and the language’s automatic management of their hierarchy, and the ability to manage a group of them). It's just the idea that a function is able to suspend its execution (that is, give up control of a thread but returning control to the system instead of the caller) for the system to resume it later. This is a concept which can be informally implemented via e.g. completion handlers, but then the language is unable to enforce things that it does for synchronous code, such as that a function either returns a value or throws an error. Notice also that this has nothing to do with actors, which although integrated with the concurrency system, are simply a means to protect mutable state.

Notice that [SE-0296 – Async/await](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#launching-async-tasks) says:

> Because only async code can call other async code, this proposal provides no way to initiate asynchronous code. This is intentional: all asynchronous code runs within the context of a "task", a notion which is defined in the Structured Concurrency proposal.

Read-only can be `async` too, e.g. `await maybeImage?.thumbnail`. They need an explicit getter so they can be marked `get async`. Initializers can be `async` too.

`await` also works in `for` loops for iterating over async sequences. See the "Meet AsyncSequence" section.

When a function resumes, there's no guarantee it'll do so on the same thread as before.

#### Testing

`XCTest` supports `async` test functions out of the box — removing the need for expectations.

(They don't address what to do if you'd like a timeout.)

#### Bridging from sync to async

How do you call async code in a context that doesn't support concurrency? This is where a taste of `Task` comes in.

```swift
Task {
  // something
}}
```

#### Existing APIs that take completion handlers

The compiler provides `async` alternatives to Objective-C methods that take completion handlers.

_Furthermore_, given delegate or data source methods that receive a completion handler (which are used to inform the framework when some work has completed), the compiler creates an `async` alternative.

> We recommend that `async` functions omit leading words like `get`, that communicate when the results of a call are not directly returned.

#### Async alternatives and continuations

To use a callback method inside an async function? Use `withCheckedThrowingContinuation`. The continuation has `resume(throwing:)` and `resume(returning:)` methods.

A continuation must be resumed exactly once – < 1 results in a warning, > 1 results in a fatal error.

### [WWDC 2021 10058 – Meet AsyncSequence](https://developer.apple.com/videos/play/wwdc2021/10058)

I thought perhaps it would be interesting to look at this next instead of going on to structured concurrency and actors, since, just like async/await, it's just another extension of existing synchronous programming ideas.

Unlocks the `for (try) await` syntax.

`AsyncSequence` has all the expected `Sequence` functionality like `map`, `reduce`, `dropFirst()`.

> `AsyncSequence` will suspend on each element, and resume when the underlying iterator produces a value or throws.

Unlike `Sequence`, they can throw an error.

I don't understand what happens if multiple people share an async sequence. Need a deeper dive into the documentation on this one.

Bear in mind that it's quite common for an async sequence not to terminate. (You might, for example, want to wrap the iteration in a separate `Task` in that case. That way, you can also externally cancel the iteration by cancelling the task. _Presumably_, iteration has no special handling of cancellation and you still need to cooperate and check for it.)

#### Iteration is not the only way to interact with an `AsyncSequence`

For example, you could `await center.notifications(named: …).first { … }`.

#### System frameworks

- `FileHandle` adds `bytes: AsyncBytes`
- there's an extension on `AsyncSequence` that converts an `AsyncSequence` of bytes into one of lines
- `URL` adds convenience `resourceBytes: AsyncBytes` and `lines: AsyncLineSequence<AsyncBytes>` async sequences.
- `URLSession` has instance method `func bytes(for: URLRequest) async throws -> (AsyncBytes, URLResponse)`
- Await notifications synchronously – `NotificationCenter` adds `func notifications(named: Notification.Name, object: AnyObject) -> Notifications`

#### How can I make my own `AsyncSequence`?

Let's see how to adapt existing patterns such as (callbacks / delegates) that are executed multiple times, which don't require any response back.

Our bridge to the `AsyncSequence` world is `AsyncStream`, which vends a continuation with a `yield` function (and also an `onTermination` which they just say "handles termination and cleanup" – one to understand better)

```swift
let quakes = AsyncStream(Quake.self) { continuation in
	let monitor = QuakeMonitor()
	monitor.quakeHandler = { quake in
		continuation.yield(quake)
	}
	continuation.onTermination = { _ in
		monitor.stopMonitoring()
	}
	monitor.startMonitoring()
}
```

So, something that's not clear to me is what the consequences are of the fact that simply creating this stream starts some work happening. Is that different to the way things work in Combine / Rx? I don't know enough about those models either to have much to say on this yet though.

Sounds like there's other stuff to understand about `AsyncSequence`, like how it handles buffering (and what that even means).

There's also `AsyncThrowingStream` if you want to be able to throw errors.

#### Language

I'm not sure what the correct language is that corresponds to concepts like "publish an element", if I wanted to document an API.

#### Time

I think — from seeing one of the Swift Evolution proposals — that async sequences are bound to some concept of time and of representing it. But that wasn't mentioned here. Another one to look into.

### [WWDC 2022 110355 – Meet Swift Async Algorithms](https://developer.apple.com/videos/play/wwdc2022/110355/)

Sounds like this is the package that introduces interaction with `Clock`.

#### Multi-input algorithms

Combining async sequences into a single output

1. Zip

   Combines values into tuples. Rethrows errors. Each side is waited concurrently (i.e. one doesn't block the other)

2. Merge

   Combine multiple AsyncSequences into one AsyncSequence

   If any of the iterations produces an error, the other iterations are cancelled.

#### New Swift APIs for handling time

There are some APIs for leveraging the new `Clock`, `Instant` and `Duration` in Swift 5.7. Let's first understand what these types are.

- `Clock`: Protocol for defining time. Defines a way to wake up after a given instant and a concept of now. Two of the most common ones are `SuspendingClock` (stops when machine sleeps) and `ContinuousClock` (always runs). We have `clock.sleep(until:)` and `clock.measure { … }`.

#### Algorithms for handling time (in Async Algorithms package)

1. Debounce – `debounce(for: .milliseconds(300))`

   Awaits a quiescence period to produce events. Rethrows failures immediately. Used for example for rate limiting searches when user enters input

2. Chunks – groups elements into collections by count, time, or content

   e.g. `let batches = outboundMessages.chunked(by: .repeating(every: .milliseonds(500))`

   Used e.g. for batching requests to the server

#### Collection initializers

Initialize `Dictionary`, `Set` or `Array` from (known finite) async sequences

## Swift Package Manager

### [WWDC 2022 110359 – Meet Swift Package plugins](https://developer.apple.com/videos/play/wwdc2022/110359/)

A Swift script that can perform actions on a Swift package. Uses a special API provided for this purpose.

They're themselves implemented as Swift packages. A plugin can use more than one source file. A Swift package can define more than one plugin. Specialized packages can be private to the package that provides it. But also can be made public by defining it as a package product.

There are two kinds:

- Command plugins
  - Run whenever you want to, e.g. format source code, or prepare for distribution. In general, things you might have arbitrary scripts for today
  - Can ask for permission to modify files in the package (useful for formatting)
  - But might also not need any write permissions, e.g. to just generate stats.
- Build tool plugins
  - Extend the build system’s dependency graph
  - For e.g. generating source code

#### An example of using a command plugin

Accessible from the right-click menu on `Package.swift` in Xcode. It then asks you which of the targets you wish to pass to the plugin. You can choose to invoke on the whole package. You can also pass custom arguments to the plugin.

You can also use the `swift package plugin` subcommand. `swift package plugin --list` to list the action verbs, and `swift package <verb>` to invoke plugin.

#### How do they work?

Each plugin runs as a separate process (in a sandbox that prevents network access and only has limited file system write access, e.g. build outputs directory). They have access to:

- a distilled representation of the input package, including its source files
- information about the package’s dependencies

Plugins can extend sandbox, ask for permission to also modify files in the package source directory.

Plugins can emit warnings and errors.

The `PackagePlugin` provides the APIs.

```swift
@main
struct MyPlugin: CommandPlugin {
	// Entry points specific to package capability
}
```

#### More about command plugins

- They’re run interactively, not during a build
- Usually depend on other tools to do the actual work
- "Xcode will build any required tools from source"

#### More about build plugins

- Supports build command and prebuild commands
- Output files are stored with other build artifacts, not among package sources
- The entry point is the `createBuildCommands(context: PluginContext, target: Target) throws -> [Command]`
- The two types of build commands:
  - Build commands run as part of the build, they specify their input and output paths, and are only run when outputs missing or inputs change
  - Prebuild commands run before _every_ build starts and can generate outputs whose names can't be known beforehand

To specify which build tool plugins to apply to a package target, there's a new `plugins` parameter available on targets in `Package.swift`.

I wonder if there's a way to preview the generated code?
